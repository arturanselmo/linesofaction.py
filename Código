import pygame
import sys
from pygame.locals import *
import copy
import random

# Constantes para o Menu
MENU_WIDTH = 800
MENU_HEIGHT = 600
BUTTON_WIDTH = 300
BUTTON_HEIGHT = 60
BUTTON_COLOR = (50, 50, 50)
BUTTON_HOVER_COLOR = (80, 80, 80)
TEXT_COLOR = (255, 255, 255)
TITLE_COLOR = (255, 255, 255)
BG_COLOR = (30, 10, 50)

# Constantes para o Jogo
BOARD_SIZE = 8
SQUARE_SIZE = 80
GAME_WIDTH = BOARD_SIZE * SQUARE_SIZE
GAME_HEIGHT = BOARD_SIZE * SQUARE_SIZE
LIGHT_SQUARE = (240, 217, 181)
DARK_SQUARE = (181, 136, 99)
BLACK_PIECE_COLOR = (0, 0, 0)
WHITE_PIECE_COLOR = (255, 255, 255)
SELECTED_COLOR = (0, 255, 0)
VALID_MOVE_COLOR = (0, 0, 255)
GAME_BG_COLOR = (50, 50, 50)

# AI Constants
MAN_VALUE = 10
MAX_DEPTH_EASY = 1
MAX_DEPTH_HARD = 3
MAX_DEPTH_VERY_HARD = 8  # New very hard difficulty

# Inicialização do Pygame
pygame.init()
screen = pygame.display.set_mode((MENU_WIDTH, MENU_HEIGHT))
pygame.display.set_caption("Lines of Action - Menu")
clock = pygame.time.Clock()

# Fontes
title_font = pygame.font.SysFont("Arial", 72, bold=True)
button_font = pygame.font.SysFont("Arial", 36)
game_font = pygame.font.SysFont(None, 36)

# Funções do Menu
def draw_gradient_background():
    for y in range(MENU_HEIGHT):
        r = 30 + (y / MENU_HEIGHT) * 20
        g = 10 + (y / MENU_HEIGHT) * 20
        b = 50 + (y / MENU_HEIGHT) * 50
        pygame.draw.line(screen, (int(r), int(g), int(b)), (0, y), (MENU_WIDTH, y))

def draw_button(text, x, y, width, height, hover=False):
    color = BUTTON_HOVER_COLOR if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, (x, y, width, height), border_radius=10)
    pygame.draw.rect(screen, TEXT_COLOR, (x, y, width, height), 2, border_radius=10)
    text_surface = button_font.render(text, True, TEXT_COLOR)
    text_rect = text_surface.get_rect(center=(x + width // 2, y + height // 2))
    screen.blit(text_surface, text_rect)

# Funções do Jogo
def init_board():
    board = [[None for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
    for col in range(1, BOARD_SIZE - 1):
        board[0][col] = "B"
        board[BOARD_SIZE - 1][col] = "B"
    for row in range(1, BOARD_SIZE - 1):
        board[row][0] = "W"
        board[row][BOARD_SIZE - 1] = "W"
    return board

def draw_board(screen, board, selected, valid_moves=None):
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            square_color = LIGHT_SQUARE if (row + col) % 2 == 0 else DARK_SQUARE
            rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)
            pygame.draw.rect(screen, square_color, rect)
            if selected == (row, col):
                pygame.draw.rect(screen, SELECTED_COLOR, rect, 3)
            if valid_moves and (row, col) in valid_moves:
                pygame.draw.rect(screen, VALID_MOVE_COLOR, rect, 3)
            piece = board[row][col]
            if piece is not None:
                center = (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2)
                radius = SQUARE_SIZE // 2 - 8
                if piece == "B":
                    pygame.draw.circle(screen, BLACK_PIECE_COLOR, center, radius)
                elif piece == "W":
                    pygame.draw.circle(screen, WHITE_PIECE_COLOR, center, radius)
                    pygame.draw.circle(screen, BLACK_PIECE_COLOR, center, radius, 2)

def get_board_pos(mouse_pos):
    x, y = mouse_pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    if 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE:
        return (row, col)
    return None

def count_pieces_in_line(board, row, col, dr, dc):
    count = 0
    r, c = row, col
    while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        if board[r][c] is not None:
            count += 1
        r += dr
        c += dc
    r, c = row - dr, col - dc
    while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        if board[r][c] is not None:
            count += 1
        r -= dr
        c -= dc
    return count

def sign(x):
    return (x > 0) - (x < 0)

def is_valid_move(board, selected, dest, current_player):
    sr, sc = selected
    dr = dest[0] - sr
    dc = dest[1] - sc
    if not ((dr == 0 and dc != 0) or (dc == 0 and dr != 0) or (abs(dr) == abs(dc) and dr != 0)):
        return False, "Movimento fora de linha reta"
    norm_dr = sign(dr)
    norm_dc = sign(dc)
    n = count_pieces_in_line(board, sr, sc, norm_dr, norm_dc)
    expected_dest = (sr + n * norm_dr, sc + n * norm_dc)
    if expected_dest != dest:
        return False, "Distância incorreta; deve mover {} casas".format(n)
    for i in range(1, n):
        r = sr + i * norm_dr
        c = sc + i * norm_dc
        if board[r][c] is not None:
            if board[r][c] != current_player:
                return False, "Não pode saltar sobre peças adversárias"
    dest_piece = board[dest[0]][dest[1]]
    if dest_piece is not None and dest_piece == current_player:
        return False, "Destino ocupado por peça amiga"
    return True, ""

def compute_valid_moves(board, selected, current_player):
    valid_moves = []
    if selected is None:
        return valid_moves
    sr, sc = selected
    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    for dr, dc in directions:
        n = count_pieces_in_line(board, sr, sc, dr, dc)
        if n == 0:
            continue
        candidate = (sr + n * dr, sc + n * dc)
        r, c = candidate
        if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
            continue
        valid, _ = is_valid_move(board, selected, candidate, current_player)
        if valid:
            valid_moves.append(candidate)
    return valid_moves

def get_all_pieces(board, player):
    positions = []
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            if board[row][col] == player:
                positions.append((row, col))
    return positions

def check_connected(board, player):
    pieces = get_all_pieces(board, player)
    if not pieces:
        return False
    visited = set()
    stack = [pieces[0]]
    while stack:
        pos = stack.pop()
        if pos in visited:
            continue
        visited.add(pos)
        r, c = pos
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < BOARD_SIZE and 0 <= nc < BOARD_SIZE:
                    if board[nr][nc] == player and (nr, nc) not in visited:
                        stack.append((nr, nc))
    return len(visited) == len(pieces)

def show_message(screen, text):
    overlay = pygame.Surface((GAME_WIDTH, GAME_HEIGHT))
    overlay.set_alpha(200)
    overlay.fill((0, 0, 0))
    screen.blit(overlay, (0, 0))
    msg = game_font.render(text, True, (255, 255, 0))
    msg_rect = msg.get_rect(center=(GAME_WIDTH//2, GAME_HEIGHT//2))
    screen.blit(msg, msg_rect)
    pygame.display.flip()
    pygame.time.wait(3000)

# AI Functions
def get_ai_move(board, ai_player, difficulty="hard"):
    moves = get_all_valid_moves(board, ai_player)
    if not moves:
        return None
    
    if difficulty == "easy":
        move_scores = []
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, MAX_DEPTH_EASY - 1, False, "W" if ai_player == "B" else "B", float('-inf'), float('inf'))
            move_scores.append((move, score))
        total_score = sum(max(0, score + 1000) for _, score in move_scores)
        if total_score == 0:
            return random.choice(moves)
        weights = [max(0, score + 1000) / total_score for _, score in move_scores]
        return random.choices([move for move, _ in move_scores], weights=weights, k=1)[0]
    else:
        # Hard or Very Hard mode with alpha-beta pruning
        depth = MAX_DEPTH_VERY_HARD if difficulty == "very_hard" else MAX_DEPTH_HARD
        best_move, best_score = None, float('-inf')
        alpha, beta = float('-inf'), float('inf')
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, depth - 1, False, "W" if ai_player == "B" else "B", alpha, beta)
            if score > best_score:
                best_score, best_move = score, move
            alpha = max(alpha, best_score)
        return best_move

def minimax(board, depth, is_maximizing, player, alpha, beta):
    if depth == 0 or is_game_over(board):
        return evaluate_board(board, "B")  # AI evaluation from Black's perspective
    if is_maximizing:
        max_score = float('-inf')
        moves = get_all_valid_moves(board, player)
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, depth - 1, False, "W" if player == "B" else "B", alpha, beta)
            max_score = max(max_score, score)
            alpha = max(alpha, max_score)
            if beta <= alpha:
                break  # Alpha-beta pruning
        return max_score
    else:
        min_score = float('inf')
        moves = get_all_valid_moves(board, player)
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, depth - 1, True, "W" if player == "B" else "B", alpha, beta)
            min_score = min(min_score, score)
            beta = min(beta, min_score)
            if beta <= alpha:
                break  # Alpha-beta pruning
        return min_score

def evaluate_board(board, ai_player):
    score = 0
    opponent = "W" if ai_player == "B" else "B"
    ai_pieces = len(get_all_pieces(board, ai_player))
    opp_pieces = len(get_all_pieces(board, opponent))
    score += MAN_VALUE * (ai_pieces - opp_pieces)
    if check_connected(board, ai_player):
        score += 1000
    if check_connected(board, opponent):
        score -= 1000
    return score

def get_all_valid_moves(board, player):
    moves = []
    pieces = get_all_pieces(board, player)
    for piece in pieces:
        valid_moves = compute_valid_moves(board, piece, player)
        for dest in valid_moves:
            moves.append((piece, dest))
    return moves

def apply_move(board, move):
    new_board = copy.deepcopy(board)
    (sr, sc), (dr, dc) = move
    if new_board[dr][dc] is not None and new_board[dr][dc] != new_board[sr][sc]:
        new_board[dr][dc] = None
    new_board[dr][dc] = new_board[sr][sc]
    new_board[sr][sc] = None
    return new_board

def is_game_over(board):
    return check_connected(board, "B") or check_connected(board, "W")

def iniciar_jogo(mode="pvp", difficulty="hard"):
    global screen
    screen = pygame.display.set_mode((GAME_WIDTH, GAME_HEIGHT))
    pygame.display.set_caption("Lines of Action")

    board = init_board()
    current_player = "B"  # Preto começa
    selected = None
    game_over = False
    ai_player = "W" if mode == "pvia" else None  # AI is White in PvAI

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                screen = pygame.display.set_mode((MENU_WIDTH, MENU_HEIGHT))
                pygame.display.set_caption("Lines of Action - Menu")
                return
            if game_over:
                continue
            if event.type == MOUSEBUTTONDOWN and current_player != ai_player:
                pos = get_board_pos(pygame.mouse.get_pos())
                if pos is None:
                    continue
                r, c = pos
                if selected is None:
                    if board[r][c] == current_player:
                        selected = (r, c)
                else:
                    valid, msg = is_valid_move(board, selected, pos, current_player)
                    if valid:
                        sr, sc = selected
                        dr, dc = pos
                        if board[dr][dc] is not None and board[dr][dc] != current_player:
                            board[dr][dc] = None
                        board[dr][dc] = current_player
                        board[sr][sc] = None
                        if check_connected(board, current_player):
                            draw_board(screen, board, None)
                            pygame.display.flip()
                            show_message(screen, f"Vitória para { 'Preto' if current_player=='B' else 'Branco' }!")
                            game_over = True
                        else:
                            current_player = "W" if current_player == "B" else "B"
                        selected = None
                    else:
                        print("Movimento inválido:", msg)
                        selected = None

        if not game_over and current_player == ai_player:
            move = get_ai_move(board, ai_player, difficulty)
            if move is None:
                draw_board(screen, board, None)
                pygame.display.flip()
                show_message(screen, f"Vitória para {'Preto' if ai_player == 'W' else 'Branco'}!")
                game_over = True
            else:
                (sr, sc), (dr, dc) = move
                if board[dr][dc] is not None and board[dr][dc] != ai_player:
                    board[dr][dc] = None
                board[dr][dc] = ai_player
                board[sr][sc] = None
                if check_connected(board, ai_player):
                    draw_board(screen, board, None)
                    pygame.display.flip()
                    show_message(screen, f"Vitória para {'Branco' if ai_player == 'W' else 'Preto'}!")
                    game_over = True
                else:
                    current_player = "B"

        screen.fill(GAME_BG_COLOR)
        valid_moves = compute_valid_moves(board, selected, current_player) if selected else []
        draw_board(screen, board, selected, valid_moves)
        pygame.display.flip()
        clock.tick(30)

def menu_principal():
    button_pvp = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    button_pvia_hard = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 + 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    button_pvia_easy = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 + 80, BUTTON_WIDTH, BUTTON_HEIGHT)
    button_pvia_very_hard = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 + 140, BUTTON_WIDTH, BUTTON_HEIGHT)

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if button_pvp.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvp")
                elif button_pvia_hard.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvia", difficulty="hard")
                elif button_pvia_easy.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvia", difficulty="easy")
                elif button_pvia_very_hard.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvia", difficulty="very_hard")

        draw_gradient_background()
        title_surface = title_font.render("LINES OF ACTION", True, TITLE_COLOR)
        title_rect = title_surface.get_rect(center=(MENU_WIDTH // 2, MENU_HEIGHT // 4))
        screen.blit(title_surface, title_rect)
        mouse_pos = pygame.mouse.get_pos()
        pvp_hover = button_pvp.collidepoint(mouse_pos)
        pvia_hard_hover = button_pvia_hard.collidepoint(mouse_pos)
        pvia_easy_hover = button_pvia_easy.collidepoint(mouse_pos)
        pvia_very_hard_hover = button_pvia_very_hard.collidepoint(mouse_pos)
        draw_button("PLAYER VS PLAYER", button_pvp.x, button_pvp.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvp_hover)
        draw_button("PLAYER VS IA (HARD)", button_pvia_hard.x, button_pvia_hard.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvia_hard_hover)
        draw_button("PLAYER VS IA (EASY)", button_pvia_easy.x, button_pvia_easy.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvia_easy_hover)
        draw_button("PLAYER VS IA (VERY HARD)", button_pvia_very_hard.x, button_pvia_very_hard.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvia_very_hard_hover)
        pygame.display.flip()
        clock.tick(60)

if __name__ == "__main__":
    menu_principal()
import sys
from pygame.locals import *
import copy
import random

# Constantes para o Menu
MENU_WIDTH = 800
MENU_HEIGHT = 600
BUTTON_WIDTH = 300
BUTTON_HEIGHT = 60
BUTTON_COLOR = (50, 50, 50)
BUTTON_HOVER_COLOR = (80, 80, 80)
TEXT_COLOR = (255, 255, 255)
TITLE_COLOR = (255, 255, 255)
BG_COLOR = (30, 10, 50)

# Constantes para o Jogo
BOARD_SIZE = 8
SQUARE_SIZE = 80
GAME_WIDTH = BOARD_SIZE * SQUARE_SIZE
GAME_HEIGHT = BOARD_SIZE * SQUARE_SIZE
LIGHT_SQUARE = (240, 217, 181)
DARK_SQUARE = (181, 136, 99)
BLACK_PIECE_COLOR = (0, 0, 0)
WHITE_PIECE_COLOR = (255, 255, 255)
SELECTED_COLOR = (0, 255, 0)
VALID_MOVE_COLOR = (0, 0, 255)
GAME_BG_COLOR = (50, 50, 50)

# Constantes da IA
MAN_VALUE = 10
MAX_DEPTH_EASY = 1
MAX_DEPTH_HARD = 3
MAX_DEPTH_VERY_HARD = 8

# Inicialização do Pygame
pygame.init()
screen = pygame.display.set_mode((MENU_WIDTH, MENU_HEIGHT))
pygame.display.set_caption("Lines of Action - Menu")
clock = pygame.time.Clock()

# Fontes
title_font = pygame.font.SysFont("Arial", 72, bold=True)
button_font = pygame.font.SysFont("Arial", 36)
game_font = pygame.font.SysFont(None, 36)

# Funções do Menu
def draw_gradient_background():
    for y in range(MENU_HEIGHT):
        r = 30 + (y / MENU_HEIGHT) * 20
        g = 10 + (y / MENU_HEIGHT) * 20
        b = 50 + (y / MENU_HEIGHT) * 50
        pygame.draw.line(screen, (int(r), int(g), int(b)), (0, y), (MENU_WIDTH, y))

def draw_button(text, x, y, width, height, hover=False):
    color = BUTTON_HOVER_COLOR if hover else BUTTON_COLOR
    pygame.draw.rect(screen, color, (x, y, width, height), border_radius=10)
    pygame.draw.rect(screen, TEXT_COLOR, (x, y, width, height), 2, border_radius=10)
    text_surface = button_font.render(text, True, TEXT_COLOR)
    text_rect = text_surface.get_rect(center=(x + width // 2, y + height // 2))
    screen.blit(text_surface, text_rect)

# Funções do Jogo
def init_board():
    board = [[None for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
    for col in range(1, BOARD_SIZE - 1):
        board[0][col] = "B"
        board[BOARD_SIZE - 1][col] = "B"
    for row in range(1, BOARD_SIZE - 1):
        board[row][0] = "W"
        board[row][BOARD_SIZE - 1] = "W"
    return board

def draw_board(screen, board, selected, valid_moves=None):
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            square_color = LIGHT_SQUARE if (row + col) % 2 == 0 else DARK_SQUARE
            rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)
            pygame.draw.rect(screen, square_color, rect)
            if selected == (row, col):
                pygame.draw.rect(screen, SELECTED_COLOR, rect, 3)
            if valid_moves and (row, col) in valid_moves:
                pygame.draw.rect(screen, VALID_MOVE_COLOR, rect, 3)
            piece = board[row][col]
            if piece is not None:
                center = (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2)
                radius = SQUARE_SIZE // 2 - 8
                if piece == "B":
                    pygame.draw.circle(screen, BLACK_PIECE_COLOR, center, radius)
                elif piece == "W":
                    pygame.draw.circle(screen, WHITE_PIECE_COLOR, center, radius)
                    pygame.draw.circle(screen, BLACK_PIECE_COLOR, center, radius, 2)

def get_board_pos(mouse_pos):
    x, y = mouse_pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    if 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE:
        return (row, col)
    return None

def count_pieces_in_line(board, row, col, dr, dc):
    count = 0
    r, c = row, col
    while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        if board[r][c] is not None:
            count += 1
        r += dr
        c += dc
    r, c = row - dr, col - dc
    while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
        if board[r][c] is not None:
            count += 1
        r -= dr
        c -= dc
    return count

def sign(x):
    return (x > 0) - (x < 0)

def is_valid_move(board, selected, dest, current_player):
    sr, sc = selected
    dr = dest[0] - sr
    dc = dest[1] - sc
    if not ((dr == 0 and dc != 0) or (dc == 0 and dr != 0) or (abs(dr) == abs(dc) and dr != 0)):
        return False, "Movimento fora de linha reta"
    norm_dr = sign(dr)
    norm_dc = sign(dc)
    n = count_pieces_in_line(board, sr, sc, norm_dr, norm_dc)
    expected_dest = (sr + n * norm_dr, sc + n * norm_dc)
    if expected_dest != dest:
        return False, "Distância incorreta; deve mover {} casas".format(n)
    for i in range(1, n):
        r = sr + i * norm_dr
        c = sc + i * norm_dc
        if board[r][c] is not None:
            if board[r][c] != current_player:
                return False, "Não pode saltar sobre peças adversárias"
    dest_piece = board[dest[0]][dest[1]]
    if dest_piece is not None and dest_piece == current_player:
        return False, "Destino ocupado por peça amiga"
    return True, ""

def compute_valid_moves(board, selected, current_player):
    valid_moves = []
    if selected is None:
        return valid_moves
    sr, sc = selected
    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    for dr, dc in directions:
        n = count_pieces_in_line(board, sr, sc, dr, dc)
        if n == 0:
            continue
        candidate = (sr + n * dr, sc + n * dc)
        r, c = candidate
        if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
            continue
        valid, _ = is_valid_move(board, selected, candidate, current_player)
        if valid:
            valid_moves.append(candidate)
    return valid_moves

def get_all_pieces(board, player):
    positions = []
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            if board[row][col] == player:
                positions.append((row, col))
    return positions

def check_connected(board, player):
    pieces = get_all_pieces(board, player)
    if not pieces:
        return False
    visited = set()
    stack = [pieces[0]]
    while stack:
        pos = stack.pop()
        if pos in visited:
            continue
        visited.add(pos)
        r, c = pos
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < BOARD_SIZE and 0 <= nc < BOARD_SIZE:
                    if board[nr][nc] == player and (nr, nc) not in visited:
                        stack.append((nr, nc))
    return len(visited) == len(pieces)

def show_message(screen, text):
    overlay = pygame.Surface((GAME_WIDTH, GAME_HEIGHT))
    overlay.set_alpha(200)
    overlay.fill((0, 0, 0))
    screen.blit(overlay, (0, 0))
    msg = game_font.render(text, True, (255, 255, 0))
    msg_rect = msg.get_rect(center=(GAME_WIDTH//2, GAME_HEIGHT//2))
    screen.blit(msg, msg_rect)
    pygame.display.flip()
    pygame.time.wait(3000)

# Funções da IA
def get_ai_move(board, ai_player, difficulty="hard"):
    moves = get_all_valid_moves(board, ai_player)
    if not moves:
        return None
    
    if difficulty == "easy":
        move_scores = []
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, MAX_DEPTH_EASY - 1, False, "W" if ai_player == "B" else "B", float('-inf'), float('inf'))
            move_scores.append((move, score))
        total_score = sum(max(0, score + 1000) for _, score in move_scores)
        if total_score == 0:
            return random.choice(moves)
        weights = [max(0, score + 1000) / total_score for _, score in move_scores]
        return random.choices([move for move, _ in move_scores], weights=weights, k=1)[0]
    else:
        depth = MAX_DEPTH_VERY_HARD if difficulty == "very_hard" else MAX_DEPTH_HARD
        best_move, best_score = None, float('-inf')
        alpha, beta = float('-inf'), float('inf')
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, depth - 1, False, "W" if ai_player == "B" else "B", alpha, beta)
            if score > best_score:
                best_score, best_move = score, move
            alpha = max(alpha, best_score)
        return best_move

def minimax(board, depth, is_maximizing, player, alpha, beta):
    if depth == 0 or is_game_over(board):
        return evaluate_board(board, "B")
    if is_maximizing:
        max_score = float('-inf')
        moves = get_all_valid_moves(board, player)
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, depth - 1, False, "W" if player == "B" else "B", alpha, beta)
            max_score = max(max_score, score)
            alpha = max(alpha, max_score)
            if beta <= alpha:
                break
        return max_score
    else:
        min_score = float('inf')
        moves = get_all_valid_moves(board, player)
        for move in moves:
            new_board = apply_move(board, move)
            score = minimax(new_board, depth - 1, True, "W" if player == "B" else "B", alpha, beta)
            min_score = min(min_score, score)
            beta = min(beta, min_score)
            if beta <= alpha:
                break
        return min_score

def evaluate_board(board, ai_player):
    score = 0
    opponent = "W" if ai_player == "B" else "B"
    ai_pieces = len(get_all_pieces(board, ai_player))
    opp_pieces = len(get_all_pieces(board, opponent))
    score += MAN_VALUE * (ai_pieces - opp_pieces)
    if check_connected(board, ai_player):
        score += 1000
    if check_connected(board, opponent):
        score -= 1000
    return score

def get_all_valid_moves(board, player):
    moves = []
    pieces = get_all_pieces(board, player)
    for piece in pieces:
        valid_moves = compute_valid_moves(board, piece, player)
        for dest in valid_moves:
            moves.append((piece, dest))
    return moves

def apply_move(board, move):
    new_board = copy.deepcopy(board)
    (sr, sc), (dr, dc) = move
    if new_board[dr][dc] is not None and new_board[dr][dc] != new_board[sr][sc]:
        new_board[dr][dc] = None
    new_board[dr][dc] = new_board[sr][sc]
    new_board[sr][sc] = None
    return new_board

def is_game_over(board):
    return check_connected(board, "B") or check_connected(board, "W")

def iniciar_jogo(mode="pvp", difficulty="hard"):
    global screen
    screen = pygame.display.set_mode((GAME_WIDTH, GAME_HEIGHT))
    pygame.display.set_caption("Lines of Action")

    board = init_board()
    current_player = "B"  # Preto começa
    selected = None
    game_over = False
    ai_player = "W" if mode == "pvia" else None  # IA é Branca no PvAI

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                screen = pygame.display.set_mode((MENU_WIDTH, MENU_HEIGHT))
                pygame.display.set_caption("Lines of Action - Menu")
                return
            if game_over:
                continue
            if event.type == MOUSEBUTTONDOWN and current_player != ai_player:
                pos = get_board_pos(pygame.mouse.get_pos())
                if pos is None:
                    continue
                r, c = pos
                if selected is None:
                    if board[r][c] == current_player:
                        selected = (r, c)
                else:
                    valid, msg = is_valid_move(board, selected, pos, current_player)
                    if valid:
                        sr, sc = selected
                        dr, dc = pos
                        if board[dr][dc] is not None and board[dr][dc] != current_player:
                            board[dr][dc] = None
                        board[dr][dc] = current_player
                        board[sr][sc] = None
                        if check_connected(board, current_player):
                            draw_board(screen, board, None)
                            pygame.display.flip()
                            show_message(screen, f"Vitória para { 'Preto' if current_player=='B' else 'Branco' }!")
                            game_over = True
                        else:
                            current_player = "W" if current_player == "B" else "B"
                        selected = None
                    else:
                        print("Movimento inválido:", msg)
                        selected = None

        if not game_over and current_player == ai_player:
            move = get_ai_move(board, ai_player, difficulty)
            if move is None:
                draw_board(screen, board, None)
                pygame.display.flip()
                show_message(screen, f"Vitória para {'Preto' if ai_player == 'W' else 'Branco'}!")
                game_over = True
            else:
                (sr, sc), (dr, dc) = move
                if board[dr][dc] is not None and board[dr][dc] != ai_player:
                    board[dr][dc] = None
                board[dr][dc] = ai_player
                board[sr][sc] = None
                if check_connected(board, ai_player):
                    draw_board(screen, board, None)
                    pygame.display.flip()
                    show_message(screen, f"Vitória para {'Branco' if ai_player == 'W' else 'Preto'}!")
                    game_over = True
                else:
                    current_player = "B"

        screen.fill(GAME_BG_COLOR)
        valid_moves = compute_valid_moves(board, selected, current_player) if selected else []
        draw_board(screen, board, selected, valid_moves)
        pygame.display.flip()
        clock.tick(30)

def menu_principal():
    button_pvp = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 - BUTTON_HEIGHT - 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    button_pvia_hard = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 + 20, BUTTON_WIDTH, BUTTON_HEIGHT)
    button_pvia_easy = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 + 80, BUTTON_WIDTH, BUTTON_HEIGHT)
    button_pvia_very_hard = pygame.Rect(MENU_WIDTH // 2 - BUTTON_WIDTH // 2, MENU_HEIGHT // 2 + 140, BUTTON_WIDTH, BUTTON_HEIGHT)

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if button_pvp.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvp")
                elif button_pvia_hard.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvia", difficulty="hard")
                elif button_pvia_easy.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvia", difficulty="easy")
                elif button_pvia_very_hard.collidepoint(mouse_pos):
                    iniciar_jogo(mode="pvia", difficulty="very_hard")

        draw_gradient_background()
        title_surface = title_font.render("LINES OF ACTION", True, TITLE_COLOR)
        title_rect = title_surface.get_rect(center=(MENU_WIDTH // 2, MENU_HEIGHT // 4))
        screen.blit(title_surface, title_rect)
        mouse_pos = pygame.mouse.get_pos()
        pvp_hover = button_pvp.collidepoint(mouse_pos)
        pvia_hard_hover = button_pvia_hard.collidepoint(mouse_pos)
        pvia_easy_hover = button_pvia_easy.collidepoint(mouse_pos)
        pvia_very_hard_hover = button_pvia_very_hard.collidepoint(mouse_pos)
        draw_button("PLAYER VS PLAYER", button_pvp.x, button_pvp.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvp_hover)
        draw_button("PLAYER VS IA (HARD)", button_pvia_hard.x, button_pvia_hard.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvia_hard_hover)
        draw_button("PLAYER VS IA (EASY)", button_pvia_easy.x, button_pvia_easy.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvia_easy_hover)
        draw_button("PLAYER VS IA (VERY HARD)", button_pvia_very_hard.x, button_pvia_very_hard.y, BUTTON_WIDTH, BUTTON_HEIGHT, pvia_very_hard_hover)
        pygame.display.flip()
        clock.tick(60)

if __name__ == "__main__":
    menu_principal()
